# **Что такое Git и зачем он нужен?**

Git - это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Например, для картинок - полезно для дизайнеров.

С помощью Git-a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.

Репозиторием называют хранилище вашего кода и историю его изменений. Git работает локально и все ваши репозитории хранятся в определенных папках на жестком диске.

Так же ваши репозитории можно хранить и в интернете. Обычно для этого используют три сервиса:

+ GitHub
+ Bitbucket
+ GitLab

Каждая точка сохранения вашего проекта носит название коммит (commit). У каждого commit-a есть hash (уникальный id) и комментарий. Из таких commit-ов собирается ветка. Ветка - это история изменений. У каждой ветки есть свое название. Репозиторий может содержать в себе несколько веток, которые создаются из других веток или вливаются в них.

**Как работает:**

Если посмотреть на картинку, то становиться чуть проще с пониманием. Каждый кружок, это commit. Стрелочки показывают направление, из какого commit сделан следующий. Например C3 сделан из С2 и т. д. Все эти commit находятся в ветке под названием main. Это основная ветка, чаще всего ее называют master . Прямоугольник main* показывает в каком commit мы сейчас находимся, проще говоря указатель.

![Изображение](https://habrastorage.org/getpro/habr/upload_files/81d/ab6/de0/81dab6de02b4179fc1bc8c119dfce9ca "Commits")

В итоге получается очень простой граф, состоящий из одной ветки (main) и четырех commit. Все это может превратиться в более сложный граф, состоящий из нескольких веток, которые сливаются в одну.
___
### **Установка**
Основой интерфейс для работы с Git-ом является консоль/терминал. Это не совсем удобно, тем более для новичков, но можно поставить дополнительную программу с графическим интерфейсом (кнопками, графиками и т.д.).

Но для начала, все же установим сам Git.

**Windows**. Проходим по **[этой](https://git-scm.com/download/win "скачать Git")** ссылке, выбираем под вашу ОС (32 или 64 битную), скачиваем и устанавливаем.

Для **Mac OS**. Открываем терминал и пишем:
```py
#Если установлен Homebrew
brew install git

#Если нет, то вводим эту команду. 
git --version
#После этого появится окно, где предложит установить Command Line Tools (CLT).
#Соглашаемся и ждем установки. Вместе с CLT установиться и git
```
**Linux**. Открываем терминал и вводим следующую команду:

```python
# Debian или Ubuntu
sudo apt install git

# CentOS
sudo yum install git
```
___
### **Настройка**
Вы установили себе Git и можете им пользоваться. Давайте теперь его настроим, чтобы когда вы создавали commit, указывался автор, кто его создал.

Открываем терминал (Linux и MacOS) или консоль (Windows) и вводим следующие команды:

```py
#Установим имя для вашего пользователя
#Вместо <ваше_имя> можно ввести, например, Grisha_Popov
#Кавычки оставляем
git config --global user.name "<ваше_имя>"

#Теперь установим email. Принцип тот же.
git config --global user.email "<адрес_почты@email.com>"
```
___
### **Создание репозитория**

#### Команда для инициализации нового репозитория: ___git init___

Для создания нового репозитория используется команда ___git init___. Команду git init выполняют только один раз для первоначальной настройки нового репозитория. Выполнение команды приведет к созданию нового подкаталога .git в вашем рабочем каталоге. Кроме того, будет создана новая главная ветка.

Теперь вы готовы к работе с Git локально на компьютере. Создадим наш первый репозиторий. Для этого пройдите в папку вашего проекта.

```py
#Для Linux и MacOS путь может выглядеть так /Users/UserName/Desktop/MyProject
#Для Windows например С://MyProject
cd <путь_к_вашему_проекту>

#Инициализация/создание репозитория
git init
```
Теперь Git отслеживает изменения файлов вашего проекта. Но, так как вы только создали репозиторий в нем нет вашего кода. Для этого необходимо создать commit.

```py
#Добавим все файлы проекта в нам будующий commit
git add .
#Или так
git add --all

#Если хотим добавить конкретный файл то можно так
git add <имя_файла> 

#Теперь создаем commit. Обязательно указываем комментарий.
#И не забываем про кавычки
git commit -m "<комментарий>"
```
___
### **Процесс работы с Git**

Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:

+ Создан новый функционал
+ Добавлен новый блок на верстке
+ Исправлены ошибки по коду
+ Вы завершили рабочий день и хотите сохранить код

Это поможет держать ваши ветки в чистоте и порядке. Тем самым, вы будете видеть историю изменений по каждому нововведению в вашем проекте, а не по каждому файлу.

___
### **Визуальный интерфейс**

Существуют дополнительные программы для облегчения использования Git. Некоторые текстовые редакторы или полноценные среды разработки уже включают в себя вспомогательный интерфейс для работы с ним.

Но существуют и отдельные программы по работе с Git:

+ GitHub Desktop
+ Sourcetree
+ GitKraken

___
### **Создаем свой первый проект и выкладываем на GitHub**

Давайте разберемся как это сделать, с помощью среды разработки Visual Studio Code (VS Code). Перед началом предлагаю зарегистрироваться на GitHub.

Создайте папку, где будет храниться ваш проект. Если такая папка уже есть, то создавать новую не надо. После открываем VS Code.

![1](https://habrastorage.org/getpro/habr/upload_files/415/4fe/297/4154fe297d8f2d82b7d7c4f44b986e00)

1. Установите себе дополнительно анализаторы кода для JavaScript и PHP
2. Откройте вашу папку, которую создали ранее. После этого у вас появится вот такой интерфейс:

![2](https://habrastorage.org/getpro/habr/upload_files/536/76a/b32/53676ab32ff10608c9a4748af3740cbd)

1. Здесь будут располагаться все файлы вашего проекта
2. Здесь можно работать с Git-ом
3. Кнопка для создания нового файла
4. Кнопка для создания новой папки

*Если ваш проект пустой, то создайте новый файл и назовите его index.html . После этого откроется окно редактирования этого файла. Напишите в нем ! и нажмите кнопку Tab . Автоматически должен сгенерироваться скелет пустой HTML страницы. Не забудьте нажать ctrl+s чтобы файл сохранился.*

Теперь перейдем во вкладу для работы с Git-ом. Откроется вот такое окно:

![3](https://habrastorage.org/getpro/habr/upload_files/dcf/64a/da5/dcf64ada515fad57d956537797626035)

1. Кнопка для публикации нашего проекта на GitHub
2. После нажатия на кнопку 1 , появится всплывающее окно. Нужно выбрать второй вариант или там где присутствует фраза ...***public repository***

*Если вы хотите создать локальный репозиторий и опубликовать код в другой сервис, то необходимо нажать на кнопку ***Initialize Repository*** . После этого, вручную выбрать сервис куда публиковать.*

После того, как выбрали "Опубликовать на GitHub публичный репозиторий" (пункт 2), программа предложит вам выбрать файлы, которые будут входить в первый commit. Проставляем галочки у всех файлов, если не проставлены и жмем ОК . Вас перекинет на сайт GitHub, где нужно будет подтвердить вход в аккаунт.

Вы создали и опубликовали репозиторий на GitHub.

Теперь сделаем изменения в коде и попробуем их снова опубликовать. Перейдите во вкладку с файлами, отредактируйте какой-нибудь файл, не забудьте нажать crtl+s (Windows) или cmd+s (MacOS), чтобы сохранить файл. Вернитесь обратно во вкладу управления Git.

![4](https://habrastorage.org/getpro/habr/upload_files/72a/ac6/9eb/72aac69eb4ebe95064aaa08b844cb8dd)

Если посмотреть на значок вкладки Git, то можно увидеть цифру 1 в синем кружке. Она означает, сколько файлов у нас изменено и незакоммичено. Давайте его закоммитим и опубликуем:

1. Кнопка для просмотра изменений в файле. Необязательно нажимать, указал для справки
2. Добавляем наш файл для будущего commit
3. Пишем комментарий
4. Создаем commit
5. Отправляем наш commit в GitHub

Поздравляю, вы научились создавать commit и отправлять его в GitHub!
___
## **Совместная работа**

Представим, что вы с друзьями придумали проект и разделили обязанности. Кто-то будет делать авторизацию и регистрацию, а кто-то функционал вывода новостей. Для этого вам пригодится ветвление.

***Ветка*** - это набор commit (кружок), которые идут друг за другом. У ветки есть название, основную ветку чаще всего называют ***master*** (на картинках будет называться ***main***) . Если говорить простыми словами, то ветка master - это наш проект.

Другие ветки - это отдельное место для реализации нового функционала или исправление багов (ошибок) нашего проекта. То есть, с отдельной веткой вы делаете что угодно, а затем сливаете эти изменения в основную ветку master.

Не рекомендуется создавать commit напрямую в master . Лучше для этого заводить новую ветку и все изменения писать там.

**Для того, чтобы создать новую ветку вводим:**

```py
git branch <название_ветки>

#или вот так

git checkout -b <название_ветки>
```
Эти команды делают тоже самое, только второй вариант позволяет сразу переключиться в новую ветку. Вносить изменения в новую ветку можно сразу после ее создания.

При создании новой ветки, старайтесь называть ее кратким и ёмким именем. Чтобы сразу было понятно, что именно изменялось по проекту. Если вы используете, какую-нибудь систему для ведения задач, то можете в начале названия ветки указывать ID задачи, чтобы можно было легко найти, на основе какой задачи была создана ветка. Например вот так: 3424_fix_catalog_ajax

В каждом новом commit следует оставлять коммент и в нем описывать суть изменений.

Переключаться между ветками можно такой командой:

```py
git checkout <название_ветки>
```
После того, как вы завершили работу над своей задачей, ветку можно слить в master . Для этого нужно переключиться в ветку master и выполнить следующую команду:

```py
# Переключаемся в master
git checkout master
# Обновляем локальную ветку с сервера
git pull origin master

# Делаем merge вашей ветки, в ветку в которой вы находитесь
# В данном примере это master
git merge <название_ветки>
```
![5](https://habrastorage.org/r/w1560/getpro/habr/upload_files/574/bb2/a87/574bb2a8719a01dad2f63e803f550a66.png)

❗️ Перед тем как сливать новый merge , стоит обновить локальную ветку master , во избежания дальнейших проблем.

Команда merge берет все изменения из ветки (например bugFix) и добавляет их в ветку master.

Для того чтобы посмотреть текущее состояние ветки, например, какие файлы добавлены или не добавлены для создания commit, можно выполнить команду: ***git status***

Другие пользователи не увидят вашу ветку, пока она не будет отправлена на удаленный репозиторий. Поэтому, после того как вы слили все изменения в master , нужно отправить их в GitHub. Для этого обязательно нужно находиться в ветке master :

```py
git checkout master

# Отправляем наши изменения в GitHub
git push origin master
```

Теперь все ваши изменения, в ветке master улетели в GitHub. Таким же образом, можно отправить любую другую ветку:

```py
git checkout <название_ветки>
git push origin <название_ветки>
```

Совет. Каждый коммит лучше заливать сразу в удаленный репозиторий. Никто не застрахован от поломки собственного ПК. Поэтому чтобы не потерять все наработки, не забывайте сливать ваши изменения на GitHub.
___
### **Как же теперь другой человек получит все ваши изменения?**

Для этого вам понадобиться GitHub или любой другой сервис для хранения кода. В прошлой статье я рассказывал как отправить код в GitHub. Сейчас я покажу, как его скопировать обратно себе на компьютер.

Если у вашего друга раньше не было проекта, то ему придется его "клонировать" себе:

```py
git clone <адрес_репозитория>
```
![6](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a84/b99/f71/a84b99f712637dd2fb37b93e62f8a48c.png)

Адрес репозитория на GitHub можно получить, нажав на зеленую кнопку Code

После выполнения команды, в папке где появиться проект и ваш друг сможет с ним работать. Все ветки и их история также подтянуться.
___

### **pull request**

➜ команда для предложения изменений

➜ запрос на вливание изменений в репозиторий

В больших компаниях один ответственный за проект создает аккаунт. Другие пользователи дают команду pull request. Предлагать изменения на GitHub нужно в отдельной ветке. Сначала пользователь копирует репозиторий на свой компьютер, делает fork репозитория, затем
клонирует версию на своём ПК, создаёт ветку с предлагаемыми изменениями, отправляет изменения командой push в свой аккаунт на GitHub и даёт команду pull request.

#### Как сделать pull request

+ Делаем fork (ответвление) репозитория
+ Делаем git clone своей версии репозитория
+ Создаем новую ветку и в НЕЕ вносим свои изменения
+ Фиксируем изменения (делаем коммиты)
+ Отправляем свою версию в свой GitHub
+ На сайте GitHub нажимаем кнопку pull request

### **Теперь самое главное**

Перед тем, как создавать новый функционал и новую ветку, стоит обновить master на вашем устройстве. Для этого нужно находиться в этой ветке и выполнить следующую команду:

```py
# Переключаемся в master
git checkout master

# Подтягиваем изменения из репозитория GitHub
git pull origin master
```

Таким же образом можно актуализировать любую другую ветку, заменив название ветки master на вашу.

Для обновления всех веток сразу, можно использовать такую, команду, но не рекомендую: ***git pull***

Теперь можно создавать новую ветку и кодить.
___

# ***Вспомогательные команды***

### ___git add___

Команда git add добавляет изменение из рабочего каталога в раздел проиндексированных файлов. Она сообщает Git, что вы хотите включить изменения в конкретном файле в следующий коммит. Однако на самом деле команда git add не оказывает существенного влияния на репозиторий: изменения регистрируются в нем только после выполнения команды ___git commit___.

Наряду с этими командами вам понадобится команда git status, которая показывает состояние рабочего каталога и раздела проиндексированных файлов.

Для полноценного процесса совместной работы в Git помимо git add и git commit необходима третья команда — ___git push___. git push используется для отправки подтвержденных изменений в удаленные репозитории для совместной работы, чтобы к набору сохраненных изменений могли получить доступ другие участники команды.

#### __Распространенные опции__
+ git add < file >

    Проиндексировать все изменения в файле < file > для следующего коммита.

+ git add < directory >

    Проиндексировать все изменения в каталоге < directory > для следующего коммита.

+ git add -p

    Начать интерактивный сеанс индексирования, во время которого вы сможете выбрать части файла, которые будут добавлены в следующий коммит. Команда представит фрагмент изменений и предложит вам ввести команду. Введите y, чтобы проиндексировать фрагмент; n, чтобы игнорировать фрагмент; s, чтобы разбить его на более мелкие фрагменты; e, чтобы вручную отредактировать фрагмент; q, чтобы завершить работу с командой.
___

### ___git config___ 

После настройки удаленного репозитория его URL-адрес нужно добавить в локальный файл __git config__, а также создать вышестоящую ветку для локальных веток. Такую возможность предоставляет команда __git remote__.
```py
git remote add <remote_name> <remote_repo_url>
```
Эта команда привяжет удаленный репозиторий по адресу ＜remote_repo_url＞ к ссылке в вашем локальном репозитории ＜remote_name＞. После привязки удаленного репозитория в него можно будет отправлять локальные ветки с помощью команды __push__.
```py
git push -u <remote_name> <local_branch_name>

# Эта команда поместит ветку локального репозитория с именем < local_branc_name > в удаленный репозиторий < remote_name >.
```
Помимо конфигурирования URL-адреса удаленного репозитория, вам может потребоваться установить глобальные параметры Git, например имя пользователя или электронный адрес. Команда git config позволяет настроить инсталляцию Git (или отдельный репозиторий) из командной строки. С помощью этой команды можно установить любые настройки: от информации о пользователе до его предпочтений и характеристик репозитория. Ниже перечислены распространенные варианты конфигурации.

Git хранит варианты конфигурации в трех различных файлах, позволяющих ограничивать область видимости на уровне отдельных репозиториев (локальный), пользователя (глобальный) или всей системы (системный):

Локальный: /.git/config — настройки на уровне репозитория.
Глобальный: /.gitconfig — настройки на уровне пользователя. Здесь хранятся настройки с флагом --global.
Системный: $(prefix)/etc/gitconfig — настройки на уровне всей системы.
Укажите имя автора, которое будет использоваться для всех коммитов в текущем репозитории. Обычно для настройки параметров конфигурации для текущего пользователя используется флаг --global.
```py
git config --global user.name <name>

# Эта команда задает имя автора, которое будет использоваться для всех коммитов, выполненных текущим пользователем.
```
Добавление аргумента --local или выполнение команды без параметра уровня конфигурации приведет к установке значения user.name для текущего локального репозитория.
```py
git config --local user.email <email>

# Эта команда задает адрес электронной почты автора, который будет использоваться для всех коммитов, выполненных текущим пользователем.
```
```py
git config --global alias.<alias-name> <git-command>

# Создайте быстрые клавиши для команды Git. Это мощная возможность для создания собственных комбинаций клавиш для часто используемых команд Git. Ниже показан упрощенный пример:

git config --global alias.ci commit

# Так создается команда ci, которую можно использовать как сокращение команды git commit.
```

```py
git config --system core.editor <editor>

# Выберите текстовый редактор, используемый для таких команд, как git commit, для всех пользователей текущего компьютера. Аргумент  должен представлять собой команду, запускающую нужный редактор (например, vi). В этом примере представлен аргумент --system. Аргумент --system устанавливает настройку на уровне всей системы, включая всех пользователей и все репозитории на компьютере.
```

```py
git config --global --edit

# В текстовом редакторе откройте файл глобальной конфигурации для редактирования вручную. Подробное руководство по настройке текстового редактора для Git см. на странице Git config.
```

### ___Отмена коммитов и изменений___

В Git не существует традиционной системы отмены, как в текстовых редакторах. Лучше воздержаться от сопоставления операций Git с какой бы то ни было традиционной концепцией отмены изменений. Кроме того, Git имеет собственную систему терминов для операций отмены, числе таких терминов — сброс (reset), возврат (revert), переключение (checkout), очистка (clean) и другие.

Git можно рассматривать как инструмент для управления временной шкалой. Коммиты — это снимки моментов времени или точек интереса на временной шкале истории проекта. Кроме того, с помощью веток можно управлять несколькими временными шкалами. Когда вы выполняете операцию отмены в Git, вы, как правило, перемещаетесь назад во времени или на другую временную шкалу, где ошибок не было.

#### __Поиск утерянного: просмотр старых коммитов__

Когда в проекте сохранена история коммитов, можно повторно оценивать и анализировать любые ранее выполненные коммиты. Один из лучших инструментов для просмотра истории репозитория Git — команда git log. В примере ниже мы используем git log для получения последних коммитов популярной графической библиотеки с открытым исходным кодом.

Каждый коммит имеет уникальный идентифицирующий хеш SHA-1. Эти идентификаторы используются для перемещения по временной шкале коммитов и возвращения к коммитам. По умолчанию __git log__ показывает только коммиты текущей выбранной ветки. Но не исключено, что искомый коммит находится в другой ветке. Для просмотра всех коммитов во всех ветках используется команда __git log --branches=*__. Команда git branch позволит просмотреть и посетить другие ветки. Так, с помощью сочетания __git branch -a__ вам будет возвращен список имен всех известных веток. Просмотреть журнал коммитов одной из этих веток можно посредством команды __git log <имя_ветки>__.

После того как вы нашли ссылку на нужный коммит в истории, для перехода к нему можно использовать команду git checkout. Команда git checkout — это простой способ «загрузить» любой из этих сохраненных снимков на компьютер разработчика. При стандартном процессе разработки указатель HEAD обычно указывает на главную ветку main или другую локальную ветку. Но при переключении на предыдущий коммит HEAD указывает уже не на ветку, а непосредственно на сам коммит. Такая ситуация называется состоянием открепленного указателя HEAD, и ее можно представить так:

![9](https://wac-cdn.atlassian.com/dam/jcr:9b234e0d-ee33-4463-ac14-298c9559015d/01%20Checking%20out%20a%20previous%20commit.svg?cdnVersion=1527)

Переход к старой версии файла не перемещает указатель HEAD. Он остается в той же ветке и в том же коммите, что позволяет избежать открепления указателя HEAD. После этого можно выполнить коммит старой версии файла в новый снимок состояния, как и в случае других изменений. Соответственно, такое использование команды git checkout применительно к файлу позволяет откатиться к прежней версии отдельного файла. Для получения дополнительной информации об этих двух режимах посетите страницу команды git checkout.

#### __Просмотр старых версий__

В этом примере предполагается, что вы начали разработку безумного эксперимента, но не уверены, хотите его сохранить или нет. Чтобы принять решение, вы хотите взглянуть на состояние проекта до начала эксперимента. Прежде всего, нужно найти идентификатор редакции, которую вы хотите просмотреть.

```py
git log --oneline
```

Допустим, история вашего проекта выглядит примерно так:
```
b7119f2 Continue doing crazy things
872fa7e Try something crazy
a1e8fb5 Make some important changes to hello.txt
435b61d Create hello.txt
9773e52 Initial import
```
Для просмотра коммита «Make some important changes to hello.txt» можно использовать команду git checkout в следующем виде:

```
git checkout a1e8fb5
```

Это приведет к тому, что ваш рабочий каталог будет в точности соответствовать состоянию коммита a1e8fb5. Вы можете просматривать файлы, компилировать проект, запускать тесты и даже редактировать файлы, не боясь потерять текущее состояние проекта. Никакие внесенные здесь изменения не будут сохранены в репозитории. Чтобы продолжить разработку, необходимо вернуться к текущему состоянию проекта:

```
git checkout main
```

Предположим, вы ведете разработку в основной ветке main по умолчанию. При каждом возвращении в ветку main можно использовать команду git revert или git reset для отмены нежелательных изменений.

#### __Отмена коммита с помощью git checkout__

С помощью команды git checkout мы можем перейти к предыдущему коммиту, a1e8fb5, и вернуть репозиторий в состояние, предшествовавшее этому безумному коммиту. Переход к отдельному коммиту переведет репозиторий в состояние открепленного указателя HEAD. Работа при этом перестает принадлежать какой-либо из веток. При открепленном указателе HEAD все новые коммиты будут оставаться без родителя, пока вы не вернете ветки в положенное состояние. «Сборщик мусора» в Git удаляет коммиты без родителя. Этот сервис работает с определенными интервалами и удаляет такие коммиты без возможности восстановления. Чтобы такие коммиты не были удалены «сборщиком мусора», перед их выполнением нужно убедиться, что мы работаем в ветке.

При наличии открепленного указателя HEAD можно выполнить команду git checkout -b new_branch_without_crazy_commit. Она создаст новую ветку с именем new_branch_without_crazy_commit и совершит переход в это состояние. Теперь репозиторий находится на новой временной шкале, где нет коммита 872fa7e. На этом этапе мы можем продолжить работу в новой ветке, поскольку коммита 872fa7e не существует и его можно считать «отмененным». К сожалению, если вам нужна предыдущая ветка (возможно, это основная ветка main), такая стратегия не подходит. Поэтому рассмотрим другие варианты отмены.

#### __Отмена публичного коммита с помощью git revert__

Предположим, мы вернулись к исходному примеру истории коммитов. Истории, в которую входит коммит 872fa7e. В этот раз попробуем отмену путем обратной операции. При исполнении команды git revert HEAD Git создаст новый коммит с операцией, обратной последнему коммиту. 

На этом этапе мы снова технически «отменили» коммит 872fa7e. Хотя коммит 872fa7e по-прежнему существует в истории, новый коммит e2f9a78 отменил изменения 872fa7e. В отличие от нашей предыдущей стратегии переключения с помощью команды checkout, мы можем продолжить работать с этой же веткой, поэтому данная стратегия является удовлетворительной. Это идеальный способ отмены при работе в открытых общих репозиториях, однако если у вас есть требование вести минимальную «очищенную» историю Git, эта стратегия может не подойти.

#### __Отмена коммита с помощью git reset__

Рассмотрение этой стратегии отмены мы продолжим на нашем рабочем примере. Команда git reset — это расширяемая команда с разнообразными функциями и вариантами использования. Если мы выполним команду git reset --hard a1e8fb5, история коммитов будет сброшена до указанного коммита.

Вывод команды log показывает, что коммиты e2f9a78 и 872fa7e больше не существуют в истории. На этом этапе мы можем продолжить работу и создавать новые коммиты так, словно «безумных» коммитов никогда не было. Этот метод отмены изменений оставляет историю максимально чистой. Отмена с помощью команды reset отлично подходит для локальных изменений, но при работе в общем удаленном репозитории создает сложности. Если у нас есть общий удаленный репозиторий, в котором с помощью команды push опубликован коммит 872fa7e, и мы попытаемся выполнить команду git push для ветки, в которой с помощью команды reset была сброшена история, система Git обнаружит это и выдаст ошибку. Git будет считать, что публикуемая ветка не была обновлена, поскольку в ней отсутствуют коммиты. В таких случаях лучше использовать отмену с помощью команды git revert.

#### __Отмена неотправленных изменений__

Пока не выполнен коммит изменений в историю репозитория, они находятся в разделе проиндексированных файлов и в рабочем каталоге. Вам может потребоваться отменить изменения в этих двух областях. Раздел проиндексированных файлов и рабочий каталог являются внутренними механизмами управления состоянием Git. 

#### __Рабочий каталог__

Рабочий каталог обычно синхронизируется с локальной файловой системой. Чтобы отменить изменения в рабочем каталоге, можно просто изменить файлы с помощью привычного редактора. В системе Git есть два инструмента для управления рабочим каталогом: команда git clean для удобной отмены изменений в рабочем каталоге и команда git reset, которую можно вызвать с параметрами --mixed или --hard, чтобы сбросить изменения в рабочем каталоге.

#### __Раздел проиндексированных файлов__

Команда git add используется для добавления изменений в раздел проиндексированных файлов. Команда git reset предназначена главным образом для отмены изменений в данном разделе. Команда reset с параметром --mixed перемещает все ожидающие изменения из раздела проиндексированных файлов обратно в рабочий каталог.

#### __Отмена публичных изменений__

При командной работе в удаленных репозиториях необходимо подходить к отмене изменений с особой осторожностью. Команда git reset, как правило, считается методом локальной отмены. Ее следует использовать для отмены изменений в частной ветке. Она безопасно изолирует удаление коммитов от других веток, которые могут использоваться другими разработчиками. Проблемы возникают, когда команда reset выполняется в общей ветке и затем эта ветка удаленно публикуется с помощью команды git push. В этом случае Git блокирует выполнение команды push и сообщает, что публикуемая ветка устарела, поскольку в ней отсутствуют коммиты, которые есть в удаленной ветке.

Предпочтительная команда для отмены общей истории коммитов — git revert. Команда revert безопаснее, чем reset, так как она не удаляет коммиты из общей истории. Команда revert сохраняет отменяемые вами коммиты и создает новый коммит с операцией, обратной последнему коммиту. Этот метод можно безопасно применять в общих распределенных рабочих средах, так как удаленный разработчик может выполнить пул ветки и получить новый коммит, который отменяет его нежелательный коммит.

* Просмотреть изменения относительно двух веток можно командой:
```
git diff <исходная_ветка> <целевая_ветка>
```
* Удалить ненужную ветку:
```
git branch -d <название_ветки>
```

* Подсказки по популярным командам:
```py
# По популярным командам
git help

# Или по конкретной команде
git help <название_команды>

# Например clone
git help clone
```
